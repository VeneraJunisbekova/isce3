<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>ISCE: Radar Geometry Handling in ISCE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ISCE
   &#160;<span id="projectnumber">3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="sphinx/html/index.html"><span>Python&#160;classes</span></a></li>
      <li><a href="https://github-fn.jpl.nasa.gov/isce-3/isce/issues/"><span>Issue&#160;Tracker</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Radar Geometry Handling in ISCE </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#geomdefn">Imaging Geometry and Definitions</a><ul><li class="level2"><a href="#geomnative">Native Doppler Geometry</a></li>
<li class="level2"><a href="#geomzero">Zero Doppler Geometry</a></li>
</ul>
</li>
<li class="level1"><a href="#forwardgeom">Forward transformation - Radar geometry to Map coordinates</a><ul><li class="level2"><a href="#localTCN">Step 1: Set up local Geocentric spherical coordinate system</a></li>
<li class="level2"><a href="#rangedopeqn">Step 2: Range Doppler Equation Solution</a></li>
<li class="level2"><a href="#deminterp">Step 3: DEM interpolation</a></li>
</ul>
</li>
<li class="level1"><a href="#inversegeom">Inverse transformation - Map coordinates to Radar geometry</a><ul><li class="level2"><a href="#orbitinterp">Step 1: Orbit interpolation</a></li>
<li class="level2"><a href="#inversenewton">Step 2: Newton-Raphson iteration</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="geomdefn"></a>
Imaging Geometry and Definitions</h1>
<p>SAR focusing techniques combine information from numerous transmitted pulses to produce a high-resolution two-dimensional backscatter image of the area illuminated by the antenna footprint (see Figure below). Consequently, the observed amplitude and phase measurement at any single pixel in a SAR image cannot be attributed to any individual pulse in azimuth time or range bin in slant range. To better geolocate targets in focused SAR images, most processing approaches use various conventions based on the Range-Doppler equation to set up reference functions for compressing energy in slant range and azimuth time domains.</p>
<div class="image">
<img src="Zerodop_geometry.png" alt="Zerodop_geometry.png"/>
</div>
<p>The Range-Doppler equation establishes the relationship between the Target T located at position ( <img class="formulaInl" alt="$\mathbf{T}$" src="form_16.png"/>) and the satellite imaging location:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{2 \cdot \mathbf{V_{sat}}\left( \eta_{f,T} \right) \cdot \left( \mathbf{T} - \mathbf{R_{sat}}\left(\eta_{f,T}\right) \right)}{\lambda \cdot R_{f,T}} = f\left(\eta_{f,T}, R_{f,T}\right) \]" src="form_17.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ R_{f,T} = \left|\mathbf{T} - \mathbf{R_{sat}}\left(\eta_{f,T} \right)\right| \]" src="form_18.png"/>
</p>
<p> where</p>
<ul>
<li>
<img class="formulaInl" alt="$\eta$" src="form_19.png"/> represents slow time domain. Also referred to as azimuth time. </li>
<li>
<img class="formulaInl" alt="$R$" src="form_20.png"/> represents slant range domain. Directly related to the fast time domain. </li>
<li>
<img class="formulaInl" alt="$f\left(\eta,R\right)$" src="form_21.png"/> represents the nominal imaging Doppler model in Hz and is a function of azimuth time and slant range. Note that this may be different from the Doppler centroid of the acquired data. </li>
<li>
<img class="formulaInl" alt="$\eta_{f,T}$" src="form_22.png"/> is the Doppler azimuth time position of Target T, under the assumed imaging Doppler model. </li>
<li>
<img class="formulaInl" alt="$R_{f,T}$" src="form_23.png"/> is the slant range position of Target T, under the assumed imaging Doppler model. </li>
<li>
<img class="formulaInl" alt="$\eta_{0,T}$" src="form_24.png"/> is the zero Doppler azimuth time position of Target T. </li>
<li>
<img class="formulaInl" alt="$R_{0,T}$" src="form_25.png"/> is the zero Doppler slant range position of Target T. </li>
<li>
<img class="formulaInl" alt="$\eta_{dc,T}$" src="form_26.png"/> is the beam center azimuth time position of Target T. </li>
<li>
<img class="formulaInl" alt="$R_{dc,T}$" src="form_27.png"/> is the beam center slant range position of Target T. </li>
</ul>
<p>For a given Doppler frequency model <img class="formulaInl" alt="$f\left(\eta_{f,T},R_{f,T}\right)$" src="form_28.png"/>, the Target T would show up at azimuth line location <img class="formulaInl" alt="$ \eta_{f,T}$" src="form_29.png"/> and slant range location <img class="formulaInl" alt="$R_{f,T}$" src="form_23.png"/> in the focused image. Note that the choice of Doppler frequency model to describe the geometry of the SAR image can be arbitrary. However, there are two standard conventions widely used for easy interpretation of the imaging geometry: Native Doppler (or Beam Center) geometry and the Zero Doppler (or Tangential) geometry. ISCE supports both these conventions.</p>
<h2><a class="anchor" id="geomnative"></a>
Native Doppler Geometry</h2>
<p>The Native Doppler geometry system is the most natural system for representing SAR data. In this case, the Doppler frequency model is chosen to match the estimated Doppler Centroid of the data, i.e.:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{2 \cdot \mathbf{V_{sat}}\left( \eta_{dc,T} \right) \cdot \left( \mathbf{T} - \mathbf{R_{sat}}\left(\eta_{dc,T}\right) \right)}{\lambda \cdot R_{dc,T}} = f\left(\eta_{dc,T}, R_{dc,T}\right) \]" src="form_30.png"/>
</p>
<p>The Doppler Centroid at a given azimuth time and slant range determines the imaging geometry as well as the azimuth carrier on the data. The azimuth time and slant range correspond to the targetâ€™s passage through the center of the antenna along track footprint. The Native Doppler convention is ideal for applying antenna pattern and gain corrections. However, the Doppler Centroid of the acquired data can vary in both azimuth time and slant range. Consequently, patch processing of the SAR pulses that accounts for updated processing parameter along-track introduces complications. The dependence on Doppler Centroid also makes it a little more complicated to mosaic acquisitions on the same track that were processed with slightly different processing parameters.</p>
<p>The Native Doppler convention is primarily used by NASA JPL for generating SAR imagery for its airborne missions like UAVSAR. The ALOS PALSAR L1.1 product was also produced in Native Doppler geometry system by JAXA.</p>
<h2><a class="anchor" id="geomzero"></a>
Zero Doppler Geometry</h2>
<p>The Zero Doppler geometry system is the most widely used convention for representing SAR data. In this case, Doppler frequency model is set to zero, i.e.:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{V_{sat}}\left( \eta_{0,T} \right) \cdot \left( \mathbf{T} - \mathbf{R_{sat}}\left(\eta_{0,T}\right) \right) = 0 \]" src="form_31.png"/>
</p>
<p>The imaging geometry can be determined independent of the Doppler Centroid and central frequency of the acquisition. The vector from the satellite to target is perpendicular to the instantaneous satellite velocity. Note that in case of the zero Doppler geometry, the azimuth time corresponding to a target can lie outside the interval defined by the imaging aperture. The SAR data still has an azimuth carrier defined by the Doppler Centroid but this piece of information does not affect the geolocation or interpretation of the imaging geometry. This independence between Doppler Centroid and imaging geometry, allows one to mosaic images on the same track processed with different parameters easily.</p>
<p>The Zero Doppler convention is used by ESA and European sensors like ERS, ENVISAT (<a class="el" href="citelist.html#CITEREF_envisat2007product">[2]</a>, <a class="el" href="citelist.html#CITEREF_small2008guide">[12]</a>), Sentinel-1 <a class="el" href="citelist.html#CITEREF_piantanida2016sentinel">[9]</a> as well as TerraSAR-X and COSMO-SkyMed. The ALOS-2 PALSAR L1.1 product is also produced in Zero Doppler geometry system by JAXA.</p>
<h1><a class="anchor" id="forwardgeom"></a>
Forward transformation - Radar geometry to Map coordinates</h1>
<p>The forward geometry transformation is implemented via <a class="el" href="classisce_1_1geometry_1_1Topo.html" title="Transformer from radar geometry coordinates to map coordinates with DEM / reference altitude...">isce::geometry::Topo</a> module in ISCE.</p>
<p>This algorithm maps a given Target (T) located at azimuth time <img class="formulaInl" alt="$ \left( \eta_{dc,T} \right) $" src="form_32.png"/> and slant range <img class="formulaInl" alt="$\left( R_{dc,T}\right) $" src="form_33.png"/> in radar image coordinates to map coordinates <img class="formulaInl" alt="$\left(X_{map}, Y_{map}, h\left(X_{map}, Y_{map}\right)\right)$" src="form_34.png"/>. This is done using the given Doppler model <img class="formulaInl" alt="$\left( f_d\left(\eta,R\right)\right)$" src="form_35.png"/> and a Digital Elevation Model (DEM) <img class="formulaInl" alt="$ \left(z\left( X, Y\right)\right)$" src="form_36.png"/> as function of horizontal datum coordinates X, Y. Details of various implementations of the forward mapping algorithm can be found in a number of references (<a class="el" href="citelist.html#CITEREF_kropatsch1990generation">[6]</a>, <a class="el" href="citelist.html#CITEREF_eineder2003efficient">[1]</a>, <a class="el" href="citelist.html#CITEREF_sansosti2006geometrical">[11]</a>, <a class="el" href="citelist.html#CITEREF_nitti2011impact">[8]</a>).</p>
<p>The forward mapping problem is formulated as finding target position <img class="formulaInl" alt="$\mathbf{T}$" src="form_16.png"/>, such that the following two constraints are satisfied</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{2 \mathbf{V_{sat}\left(\eta_{dc,T}\right)} \cdot \left( \mathbf{T} - \mathbf{R_{sat}\left(\eta_{dc,T}\right)} \right)}{\lambda \cdot R_{dc,T}} = f_{dc}\left(\eta_{dc,T}, R_{dc,T} \right) \]" src="form_37.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left| \mathbf{T} - \mathbf{R_{sat}\left(\eta_{dc,T}\right)} \right | = R_{dc,T} \]" src="form_38.png"/>
</p>
<p>In ISCE, the algorithm is broken down into 4 steps. Note that all computations are performed in the Earth Centered Earth Fixed (ECEF) coordinates.</p>
<ol>
<li>
<p class="startli">Setting up of a local Geocentric spherical coordinate system at the location of the satellite. Initializing the height of the target above local sphere to a nominal value <img class="formulaInl" alt="$h_p$" src="form_39.png"/>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Solve the constrained optimization problem shown above for point <img class="formulaInl" alt="$\mathbf{T}$" src="form_16.png"/> on the local sphere. Convert the location of the coordinates to map coordinates - <img class="formulaInl" alt="$X_{map}, Y_{map}$" src="form_40.png"/>. Note that only the horizontal location information is used from this estimate for the next stage of the algorithm.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Interpolate the given DEM <img class="formulaInl" alt="$ z\left(X,Y\right) $" src="form_41.png"/> to obtain <img class="formulaInl" alt="$z_{map}$" src="form_42.png"/>. Conver the coordinates <img class="formulaInl" alt="$\left(X_{map}, Y_{map}, z_{map}\right)$" src="form_43.png"/> to the local spherical system and estimate the height above the local sphere <img class="formulaInl" alt="$h_{est}$" src="form_44.png"/>.</p>
<p class="endli"></p>
</li>
<li>
Go back to Step 1, with <img class="formulaInl" alt="$h_0 = h_{est}$" src="form_45.png"/>. Continue iterating till <img class="formulaInl" alt="$h_{est}$" src="form_44.png"/> converges. When the algorithm converges <img class="formulaInl" alt="$\left(X_{map}, Y_{map}, z_{map}\right)$" src="form_43.png"/> from the latest iteration represents the target location in map coordinates. </li>
</ol>
<p>Each of the steps is described in detail below. The algorithm can support analysis in both Native Doppler and Zero Doppler coordinate systems. For Zero Doppler coordinate system, the Doppler model <img class="formulaInl" alt="$ \left( f_{d}\left(\eta_{dc,T}, R_{dc,T}\right) \right) $" src="form_46.png"/> is set to zero.</p>
<h2><a class="anchor" id="localTCN"></a>
Step 1: Set up local Geocentric spherical coordinate system</h2>
<p>Let <img class="formulaInl" alt="$\mathbf{R_{sat}}$" src="form_47.png"/> and <img class="formulaInl" alt="$\mathbf{V_{sat}}$" src="form_48.png"/> represent the position of the satellite corresponding to the azimuth time of the target of interest. The Geocentric radius at the intersection of the reference Ellipsoid and the vector connecting the satellite position to the center of the Ellipsoid is given by</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ R_c =\frac{\left| \mathbf{R_{sat}}\right|} {\sqrt{ \left( \frac{X_{sat}}{a_e} \right)^2 + \left( \frac{Y_{sat}}{a_e} \right)^2 + \left( \frac{Z_{sat}}{b_e} \right)^2 }} \]" src="form_49.png"/>
</p>
<p>Relative height of the satellite along the Geocentric vector is given by</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ h_{sat} = \left| \mathbf{R_{sat}} \right| - R_c \]" src="form_50.png"/>
</p>
<p>We can set up a local orthogonal coordinate system on a sphere with radius <img class="formulaInl" alt="$R_c$" src="form_51.png"/> at <img class="formulaInl" alt="$\mathbf{R_{sat}}$" src="form_47.png"/> as follows:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hat{n} = -\left[ \frac{X_{sat}}{\left| \mathbf{R_{sat}} \right|}, \frac{Y_{sat}}{\left| \mathbf{R_{sat}} \right|}, \frac{Z_{sat}}{\left| \mathbf{R_{sat}} \right|} \right] \]" src="form_52.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hat{c} = \frac{\mathbf{V_{sat}} \times \hat{n}}{\left| \mathbf{V_{sat}} \times \hat{n} \right| } \]" src="form_53.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hat{t} = \hat{c} \times \hat{n} \]" src="form_54.png"/>
</p>
<p>where </p>
<ul>
<li>
<img class="formulaInl" alt="$\hat{n}$" src="form_55.png"/> represents the unit vector pointing towards the center of the reference Ellipsoid. </li>
<li>
<img class="formulaInl" alt="$\hat{c}$" src="form_56.png"/> represents the axis perpendicular to the plane represented by the Geocentric vector and the satellite's velocity vector. </li>
<li>
<img class="formulaInl" alt="$\hat{t}$" src="form_57.png"/> represents the tangential component of the velocity vector </li>
</ul>
<h2><a class="anchor" id="rangedopeqn"></a>
Step 2: Range Doppler Equation Solution</h2>
<p>Assuming that the target point is located at height <img class="formulaInl" alt="$h_0$" src="form_58.png"/> above the local sphere of radius ( <img class="formulaInl" alt="$R_c$" src="form_51.png"/>), the slant range vector of length <img class="formulaInl" alt="$R_0$" src="form_59.png"/> can be represented in the local TCN basis as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{T} = \mathbf{R_{sat}} + \alpha \cdot \hat{t} + \beta \cdot \hat{c} + \gamma \cdot \hat{n} \]" src="form_60.png"/>
</p>
<p>Using the law of cosines on the local sphere, we can show that</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \gamma = \frac{R_0}{2} \cdot \left[ \left( \frac{h_{sat} + R_c}{R_0}\right) + \left( \frac{R_0}{h_{sat} + R_c } \right) - \left( \frac{h_0 + R_c}{h_{sat}+R_c} \right) \cdot \left( \frac{h_0 + R_{curv}}{R_0} \right) \right] \]" src="form_61.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \alpha = \frac{f_d\left(R_0\right) \cdot \lambda \cdot R_0}{2 \cdot \left| \mathbf{V_{sat}} \right|} - \gamma \cdot \frac{\hat{n} \cdot \hat{v}}{\hat{t} \cdot \hat{v}} \]" src="form_62.png"/>
</p>
<p>where <img class="formulaInl" alt="$\hat{v} = \frac{\mathbf{V_{sat}}}{\left| \mathbf{V_{sat}} \right|}$" src="form_63.png"/> is the unit vector along the satellite velocity.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \beta = -L\cdot \sqrt{R_0^2 - \gamma^2 - \alpha^2} \]" src="form_64.png"/>
</p>
<p>where <img class="formulaInl" alt="$L=-1$" src="form_65.png"/> for right looking imaging geometry and <img class="formulaInl" alt="$L=+1$" src="form_66.png"/> for left looking imaging geometry. Once <img class="formulaInl" alt="$ \alpha, \beta$" src="form_67.png"/> and <img class="formulaInl" alt="$\gamma$" src="form_68.png"/> are computd, we can compute the location of the target in Cartesian space <img class="formulaInl" alt="$\left( \mathbf{T} \right)$" src="form_69.png"/>. The target location can be converted into map coordinates as <img class="formulaInl" alt="$\left( X_{map}, Y_{map}, z_map\left(X_{map}, Y_{map}\right) \right)$" src="form_70.png"/> using standard transformations (see <a class="el" href="structisce_1_1core_1_1ProjectionBase.html" title="Abstract base class for individual projections. ">isce::core::ProjectionBase</a>).</p>
<h2><a class="anchor" id="deminterp"></a>
Step 3: DEM interpolation</h2>
<p>DEMs are commonly provided in non-Cartesian coordinates (e.g., Lat-Long grid, UTM grid, EASE-2 grid) and contain heights above a geoid (e.g., EGM96 or EGM08). The geometry mapping algorithms presented in this document explicitly assume that the DEMs have been adjusted to represent heights above the representative ellipsoid like WGS84. Standard GIS tools offer numerous methods of interpolating height data (e.g., nearest neighbor, bilinear, and bicubic). We recommend using biquintic interpolation method <a class="el" href="citelist.html#CITEREF_kidner1999s">[4]</a> as this appears to be least susceptible to difference between the DEM resolution and the radar grid resolution to which it is being mapped. Moreover, biquintic polynomials represent the smallest order polynomials that preserve slope information when interpolating across neighboring cells in the DEM.</p>
<p>For the forward mapping algorithm, we interpolate the DEM at location <img class="formulaInl" alt="$\left(X_{map}, Y_{map}\right)$" src="form_71.png"/> to determine the new <img class="formulaInl" alt="$z_{map}$" src="form_42.png"/>. This new target location is then transformed into the ECEF coordinate system and the new height estimate <img class="formulaInl" alt="$h_est$" src="form_72.png"/> is given by</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ h_{est} = \left| \mathbf{T} \right| - R_c \]" src="form_73.png"/>
</p>
<p>and <img class="formulaInl" alt="$h_{est}$" src="form_44.png"/> becomes the initial height estimate <img class="formulaInl" alt="$h_0$" src="form_58.png"/> for the next iteration of the algorithm. When trying to estimate the target location on a reference ellipsoid, the DEM is assumed to be of constant height <img class="formulaInl" alt="$z_{map}$" src="form_42.png"/> and the algorithm converges in two or three iterations.</p>
<h1><a class="anchor" id="inversegeom"></a>
Inverse transformation - Map coordinates to Radar geometry</h1>
<p>This algorithm maps a given target ( <img class="formulaInl" alt="$\mathbf{T}$" src="form_16.png"/>) located at <img class="formulaInl" alt="$\left (X,Y, z\left(X,Y\right)\right)$" src="form_74.png"/> in map coordinates represented by horizontal datum <img class="formulaInl" alt="$\left(X,Y\right)$" src="form_75.png"/> to radar images coordinates - azimuth time ( <img class="formulaInl" alt="$\eta$" src="form_19.png"/>) and slant range ( <img class="formulaInl" alt="$R$" src="form_20.png"/>), using a given Doppler model <img class="formulaInl" alt="$\left(f_d \left(\eta,R\right)\right)$" src="form_76.png"/>. Different implementations of the Inverse Mapping Algorithm can be found in several references (<a class="el" href="citelist.html#CITEREF_eineder2003efficient">[1]</a>, <a class="el" href="citelist.html#CITEREF_sansosti2006geometrical">[11]</a>, <a class="el" href="citelist.html#CITEREF_nitti2011impact">[8]</a>).</p>
<p>The ISCE implementation of the algorithm is based on the simple Newton-Raphson method and has three key steps:</p>
<ol>
<li>
We start with an initial guess for the azimuth time ( <img class="formulaInl" alt="$\eta_g$" src="form_77.png"/>) and interpolate the state vectors provided with the radar metadata to estimate the satellite position <img class="formulaInl" alt="$\left( \mathbf{R_{sat}\left( \eta_g\right)} \right)$" src="form_78.png"/> and velocity <img class="formulaInl" alt="$ \left( \mathbf{V_{sat}\left( \eta_g \right)} \right)$" src="form_79.png"/>. </li>
<li>
Perform a Newton Raphson iteration to determine the change to be applied to our azimuth time guess ( <img class="formulaInl" alt="$\Delta \eta $" src="form_80.png"/>). </li>
<li>
Continue iterations until the change in azimuth time ( <img class="formulaInl" alt="$\Delta \eta$" src="form_81.png"/>) is negligible. When the algorithm converges <img class="formulaInl" alt="$\eta_g$" src="form_77.png"/> represents the azimuth time and the distance between satellite location at <img class="formulaInl" alt="$\eta_g$" src="form_77.png"/> represents the slant range in radar image coordinates. </li>
</ol>
<p>Each of the steps is described in detail below. The algorithm can support analysis in both Native Doppler and Zero Doppler coordinate systems. For Zero Doppler coordinate system, the Doppler model <img class="formulaInl" alt="$\left( f_d\left(\eta_{dc,T}, R_{dc,T}\right)\right)$" src="form_82.png"/> is set to zero.</p>
<h2><a class="anchor" id="orbitinterp"></a>
Step 1: Orbit interpolation</h2>
<p>To precisely map targets from map coordinates to radar image coordinaes, we need to be able to interpolate the orbit state vectors with an accuracy on order of few mm. Two possible interpolation methods satisfy this requirement:</p>
<ol>
<li>
<p class="startli"><b>Hermite polynomial interpolation</b><br/>
 A third-order Hermite polynomial can be used to interpolate the orbit information reliably. The Hermite polynomial is constructed using 4 state vectors spanning the azimuth time epoch of interest; and combines position and velocity information for interpolating the state vectors <a class="el" href="citelist.html#CITEREF_sandwell2008accuracy">[10]</a>. Hermite polynomials works better in the scenario when the available state vectors are sampled less frequently than once every 30 seconds.</p>
<p class="endli"></p>
</li>
<li>
<b>Legendre polynomial interpolation</b><br/>
 An eighth-order Legendre polynomial can also be used to interpolate the orbit information reliably. The Legendre polynomial is constructed using 9 state vectors spanning the azimuth time epoch of interest; and interpolates the position and velocity arrays independently of each other <a class="el" href="citelist.html#CITEREF_getorbdelft">[13]</a>. This makes it suitable for use with Polar Format Algorithm as well. Legendre polynomial method performs better when the available state vectors are sampled frequently (&lt; 30 secs apart). </li>
</ol>
<p>For most modern SAR sensors, the precise position and velocity vectors in the annotation metadata are consistent with each other and can be reliably interpolated with Hermite polynomials. However, when focusing the L0B data for emergency response, the precise state vectors may not be available. Legendre polynomials are recommended for interpolation of the rapid orbits as it reduces geolocation errors.</p>
<p>At the start of the algorithm, we pick and initial azimuth time ( <img class="formulaInl" alt="$\eta_g$" src="form_77.png"/>) as the first guess. Typically, this is set to the center of the azimuth data block / scene that is being processed. After interpolation, we end up with the initial estimate for satellite position <img class="formulaInl" alt="$\left( \mathbf{R_{sat}\left( \eta_g \right)} \right)$" src="form_83.png"/> and satellite velocity <img class="formulaInl" alt="$\left( \mathbf{V_{sat}\left( \eta_g \right)} \right)$" src="form_84.png"/>.</p>
<h2><a class="anchor" id="inversenewton"></a>
Step 2: Newton-Raphson iteration</h2>
<p>The function <img class="formulaInl" alt="$y\left( \eta \right)$" src="form_85.png"/>, whose zero crossing we are trying to determine using the Newton-Raphson method can be directly derived from the Range Doppler Equation.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ y\left( \eta \right) = \mathbf{V_{sat}\left(\eta\right)} \cdot \left( \mathbf{T} - \mathbf{R_{sat}\left( \eta \right)}\right) - \frac{\lambda}{2} \cdot f_d\left( \eta, R_{dc}\left(\eta\right)\right) \cdot R_dc\left( \eta \right) = 0 \]" src="form_86.png"/>
</p>
<p>where </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ R_{dc}\left(\eta \right) = \left| \mathbf{T} - \mathbf{R_{sat}\left(\eta\right)}\right| \]" src="form_87.png"/>
</p>
<p>The adjustment to the initial guess of the azimuth time epoch ( <img class="formulaInl" alt="$\eta_g$" src="form_77.png"/>) is given by </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \eta_{new} = \eta_g - \frac{y\left( \eta_g \right)}{y^{\prime}\left( \eta_g\right)} \]" src="form_88.png"/>
</p>
<p>where </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ y^{\prime}\left( \eta \right) \approx \frac{\lambda}{2} \cdot \left[ \frac{ f_{dc}\left( \eta, R_{dc}\left( \eta \right) \right)}{R_{dc}\left( \eta \right)} + f_d^{\prime}\left( \eta, R_{dc}\left( \eta \right) \right) \right] \cdot \left( \mathbf{V_{sat}\left( \eta \right)} \cdot \left( \mathbf{T} - \mathbf{R_{sat}\left(\eta\right)} \right) - \left| \mathbf{V_{sat}\left( \eta \right)}\right|^2 \right) \]" src="form_89.png"/>
</p>
<p>The Newton-Raphson iterations are continued till the estimated azimuth time converges, i.e, the Range-Doppler equation is satisfied. When the algorithm converges <img class="formulaInl" alt="$R_{dc}\left( \eta_{new} \right)$" src="form_90.png"/> represents the slant range to the target. </p>
</div></div><!-- contents -->
<hr>
Generated for ISCE3.0 by
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.8.5.
</body>
</html>
