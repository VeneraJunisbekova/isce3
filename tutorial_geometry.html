<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ISCE: Geometry Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ISCE
   &#160;<span id="projectnumber">3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Geometry Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#geominclude">Include headers</a></li>
<li class="level1"><a href="#geomorbit">Orbit</a></li>
<li class="level1"><a href="#geomfwd">Forward mapping - determining bounding boxes</a></li>
<li class="level1"><a href="#geominv">Inverse mapping - locating corner reflectors</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="geominclude"></a>
Include headers</h1>
<p>In general, one only needs to include the following headerfiles. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;isce/core/Orbit.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="geometry_8h.html">isce/geometry/geometry.h</a>&quot;</span></div></div><!-- fragment --><p>If one is looking to use this with other features from ISCE, you might need additional appropriate header files.</p>
<h1><a class="anchor" id="geomorbit"></a>
Orbit</h1>
<p><a class="el" href="structisce_1_1core_1_1Orbit.html" title="Data structure to represent ECEF state vectors of imaging platform. ">isce::core::Orbit</a> is at the heart of all geometric manipulation in ISCE. This is just a time-tagged collection of state vectors. In this example, we will just walk through an example of constructing an Orbit object with a list of time-tagged position and velocity state vectors.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="geometry_8h.html">isce/geometry/geometry.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">    <a class="code" href="structisce_1_1core_1_1Orbit.html">isce::core::Orbit</a> orbit;</div><div class="line"></div><div class="line">    std::ifstream ifid(<span class="stringliteral">&quot;input_orbit.txt&quot;</span>);</div><div class="line">    std::string line;</div><div class="line">    </div><div class="line">    <span class="keywordflow">while</span>(std::getline(ifid, line))</div><div class="line">    {</div><div class="line">        std::stringstream stream;</div><div class="line">        std::string aztime;</div><div class="line">        <a class="code" href="namespaceisce_1_1core.html#af1248fd6851624355b9af9c38decbad2">isce::core::cartesian_t</a> pos, vel;</div><div class="line"></div><div class="line">        stream &lt;&lt; line;</div><div class="line">        std::cout &lt;&lt; line &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        stream &gt;&gt; aztime &gt;&gt; pos[0] &gt;&gt; pos[1] &gt;&gt; pos[2] &gt;&gt; vel[0] &gt;&gt; vel[1] &gt;&gt; vel[2];</div><div class="line">        <span class="comment">//Create StateVector Object</span></div><div class="line">        <a class="code" href="classisce_1_1core_1_1StateVector.html">isce::core::StateVector</a> sv;</div><div class="line">        sv.<a class="code" href="classisce_1_1core_1_1StateVector.html#a3bb93a65f6608900ef132f18874881ba">date</a>(aztime);    <span class="comment">//ISO-8601 format</span></div><div class="line">        sv.<a class="code" href="classisce_1_1core_1_1StateVector.html#ab3a4d43e8283cffb1f7bc8253ef9b80e">position</a>(pos);</div><div class="line">        sv.<a class="code" href="classisce_1_1core_1_1StateVector.html#a476f8264b9a767023c491ad8157f3940">velocity</a>(vel);</div><div class="line"></div><div class="line">        <span class="comment">//Add state vector to orbit</span></div><div class="line">        orbit.<a class="code" href="structisce_1_1core_1_1Orbit.html#a919190f179fb4d5f554e4966e6f59629">stateVectors</a>.push_back(sv);</div><div class="line">    }</div><div class="line">    ifid.close();</div><div class="line"></div><div class="line">    <span class="comment">//Assume that the state vectors are sorted on input.</span></div><div class="line">    <span class="comment">//Prepare orbit object for computations</span></div><div class="line">    orbit.<a class="code" href="structisce_1_1core_1_1Orbit.html#a422b78341f291777771a2a9cb9c3631d">reformatOrbit</a>( orbit.<a class="code" href="structisce_1_1core_1_1Orbit.html#a919190f179fb4d5f554e4966e6f59629">stateVectors</a>[0].date());</div><div class="line"></div><div class="line">    <span class="comment">//Print orbit for debugging</span></div><div class="line">    orbit.<a class="code" href="structisce_1_1core_1_1Orbit.html#a9c6d02ecb26de5284c0dc8079789f119">printOrbit</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The "input_orbit.txt" file looks like</p>
<pre class="fragment">2016-04-08T09:13:13.000000 -3752316.976337 4925051.878499 3417259.473609 3505.330104 -1842.136554 6482.122476
2016-04-08T09:13:23.000000 -3717067.52658 4906329.056304 3481886.455117 3544.479224 -1902.402281 6443.152265
...
</pre><p>In the above example, we used a 7-column text file with datetime in ISO-8601 format, ECEF position (m) and ECEF velocity (m/s). Similar readers can be easily written to parse state vector information in other formats like HDF5, XML etc.</p>
<h1><a class="anchor" id="geomfwd"></a>
Forward mapping - determining bounding boxes</h1>
<p>In this example, we will demonstrate the forward mapping algorithm by using it to determine approximate bounding boxes on the ground. See <a class="el" href="overview_geometry.html">geometry overview</a> for details on the implemented algorithm.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="geometry_8h.html">isce/geometry/geometry.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line"></div><div class="line">    <a class="code" href="structisce_1_1core_1_1Orbit.html">isce::core::Orbit</a> orbit;</div><div class="line"></div><div class="line">    <span class="comment">//Read in orbit from file</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">//Create WGS84 ellipsoid</span></div><div class="line">    <a class="code" href="classisce_1_1core_1_1Ellipsoid.html">isce::core::Ellipsoid</a> ellipse(6378137.,.0066943799901);</div><div class="line"></div><div class="line">    <span class="comment">//Early and late time from radar image metadata</span></div><div class="line">    std::vector&lt;isce::core::DateTime&gt; timetags;</div><div class="line">    timetags.push_back(<a class="code" href="structisce_1_1core_1_1DateTime.html">isce::core::DateTime</a>(<span class="stringliteral">&quot;2016-04-08T09:13:55.454821&quot;</span>));</div><div class="line">    timetags.push_back(<a class="code" href="structisce_1_1core_1_1DateTime.html">isce::core::DateTime</a>(<span class="stringliteral">&quot;2016-04-08T09:14:09.555937&quot;</span>));</div><div class="line"></div><div class="line">    <span class="comment">//Near and far slant range from radar image metadata</span></div><div class="line">    std::vector&lt;double&gt; ranges;</div><div class="line">    ranges.push_back(800000.);</div><div class="line">    ranges.push_back(950000.);</div><div class="line"></div><div class="line">    <span class="comment">//Assume height ranges - can look up an actual DEM as well if needed</span></div><div class="line">    <span class="comment">//We just use min/max to get approximate bounds</span></div><div class="line">    std::vector&lt;double&gt; zrange;</div><div class="line">    zrange.push_back(-100.);</div><div class="line">    zrange.push_back(2000.);</div><div class="line"></div><div class="line">    <span class="comment">//Wavelength from metadata</span></div><div class="line">    <span class="keywordtype">double</span> wvl = 0.06;</div><div class="line"></div><div class="line">    <span class="comment">//Look side from metadata</span></div><div class="line">    <span class="keywordtype">int</span> side = -1; <span class="comment">//Right-looking</span></div><div class="line"></div><div class="line">    <span class="comment">//Container to store sets of returned results</span></div><div class="line">    std::vector&lt;double&gt; lats;</div><div class="line">    std::vector&lt;double&gt; lons;</div><div class="line"></div><div class="line">    <span class="comment">//For each time-tag</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tt=0; tt&lt;timetags.size(); tt++)</div><div class="line">    {</div><div class="line">        <span class="comment">//Azimuth time to interpolate w.r.t reference epoch of orbit</span></div><div class="line">        <span class="keywordtype">double</span> tintp = timetags[tt].secondsSinceEpoch(orbit.<a class="code" href="structisce_1_1core_1_1Orbit.html#a8332fb47800e74433493014f3c0e76b9">refEpoch</a>);</div><div class="line">        </div><div class="line">        <span class="comment">//For each slant range</span></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> rr=0; rr&lt;ranges.size(); rr++)</div><div class="line">        {</div><div class="line">            <span class="comment">//Slant range to pixel</span></div><div class="line">            <span class="keywordtype">double</span> rng = ranges[rr];</div><div class="line">            </div><div class="line">            <span class="comment">//For each height</span></div><div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> zz=0; zz&lt;zrange.size(); zz++)</div><div class="line">            {</div><div class="line">                <span class="comment">//To store Lon/Lat/Hae of target</span></div><div class="line">                <a class="code" href="namespaceisce_1_1core.html#af1248fd6851624355b9af9c38decbad2">isce::core::cartesian_t</a> llh;</div><div class="line"></div><div class="line">                <span class="comment">//Constant height DEM</span></div><div class="line">                <a class="code" href="classisce_1_1geometry_1_1DEMInterpolator.html">isce::geometry::DEMInterpolator</a> constDEM(zrange[zz]);</div><div class="line"></div><div class="line">                <span class="comment">//Map target to DEM assuming Zero Doppler geometry</span></div><div class="line">                <span class="keywordtype">int</span> status = <a class="code" href="geometry_8h.html#a0cf2eef7a9fd1dc9e61e8058f225c438">isce::geometry::rdr2geo</a>(tintp,  <span class="comment">//aztime</span></div><div class="line">                                        rng,    <span class="comment">//slant range</span></div><div class="line">                                        0.,     <span class="comment">//doppler</span></div><div class="line">                                        orbit, </div><div class="line">                                        ellipse, </div><div class="line">                                        constDEM, </div><div class="line">                                        llh,    <span class="comment">//output LLH</span></div><div class="line">                                        wvl,    <span class="comment">//wavelength</span></div><div class="line">                                        side,   <span class="comment">//lookside</span></div><div class="line">                                        5.0e-2, <span class="comment">//distance threshold</span></div><div class="line">                                        2,     <span class="comment">//primary iterations</span></div><div class="line">                                        0,     <span class="comment">//secondary iterations,</span></div><div class="line">                                        isce::core::HERMITE_METHOD);</div><div class="line"></div><div class="line">                <span class="comment">//Convert to degrees </span></div><div class="line">                lons.push_back(llh[0] * 180.0/M_PI);</div><div class="line">                lats.push_back(llh[1] * 180.0/M_PI);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> lonresult = std::minmax_element(lons.begin(), lons.end());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Lon limits (deg): &quot;</span> &lt;&lt; lons[lonresult.first - lons.begin()] &lt;&lt; <span class="stringliteral">&quot;  &quot;</span></div><div class="line">                                &lt;&lt; lons[lonresult.second - lons.begin()] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> latresult = std::minmax_element(lats.begin(), lats.end());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Lat limits (deg): &quot;</span> &lt;&lt; lats[latresult.first - lats.begin()] &lt;&lt; <span class="stringliteral">&quot;  &quot;</span></div><div class="line">                                &lt;&lt; lats[latresult.second - lats.begin()] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                </div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="geominv"></a>
Inverse mapping - locating corner reflectors</h1>
<p>In this example, we will demonstrate the inverse mapping algorithm by using it to determine the location of a known target in a radar image.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="geometry_8h.html">isce/geometry/geometry.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line"></div><div class="line">    <a class="code" href="structisce_1_1core_1_1Orbit.html">isce::core::Orbit</a> orbit;</div><div class="line"></div><div class="line">    <span class="comment">//Read in orbit from file</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">//Create WGS84 ellipsoid</span></div><div class="line">    <a class="code" href="classisce_1_1core_1_1Ellipsoid.html">isce::core::Ellipsoid</a> ellipse(6378137.,.0066943799901);</div><div class="line"></div><div class="line">    <span class="comment">//Known targets / corner reflector locations - can be read in from a file</span></div><div class="line">    std::vector&lt;isce::core::cartesian_t&gt; targets;</div><div class="line">    targets.push_back( <a class="code" href="namespaceisce_1_1core.html#af1248fd6851624355b9af9c38decbad2">isce::core::cartesian_t</a>{{131.55, 32.85, 475.}});</div><div class="line">    targets.push_back( <a class="code" href="namespaceisce_1_1core.html#af1248fd6851624355b9af9c38decbad2">isce::core::cartesian_t</a>{{131.65, 32.95, 150.}});</div><div class="line"></div><div class="line">    <span class="comment">//Wavelength</span></div><div class="line">    <span class="keywordtype">double</span> wvl = 0.06;</div><div class="line"></div><div class="line">    <span class="comment">//Look side</span></div><div class="line">    <span class="keywordtype">int</span> side = -1; <span class="comment">//Right-looking</span></div><div class="line"></div><div class="line">    <span class="comment">//We will create a fake product with relevant metadata for use</span></div><div class="line">    <a class="code" href="classisce_1_1product_1_1ImageMode.html">isce::product::ImageMode</a> mode;</div><div class="line">    std::array&lt;size_t,2&gt; dims{{1500,1000}};</div><div class="line">    mode.<a class="code" href="classisce_1_1product_1_1ImageMode.html#a9cfd8fc4429c7f161b2c60d8487f6615">dataDimensions</a>(dims); <span class="comment">//1500 lines x 1000 pixels</span></div><div class="line">    mode.<a class="code" href="classisce_1_1product_1_1ImageMode.html#af99f799118ab544b0c7879697191c9ee">prf</a>(1000.);</div><div class="line">    mode.<a class="code" href="classisce_1_1product_1_1ImageMode.html#a311b0c9dcdb2eae3e18202a4d7674279">rangeBandwidth</a>(20.0e6);       <span class="comment">//Dummy</span></div><div class="line">    mode.<a class="code" href="classisce_1_1product_1_1ImageMode.html#affb9c4edc7f85c7bf0cbd1e838ac5bc2">wavelength</a>(0.06); </div><div class="line">    mode.<a class="code" href="classisce_1_1product_1_1ImageMode.html#acd6e644e362aa3b9d9849bd2c7f1b61f">startingRange</a>(8.0e5);</div><div class="line">    mode.<a class="code" href="classisce_1_1product_1_1ImageMode.html#a84ce518a4dcca741568893388b9432c5">rangePixelSpacing</a>(10.);</div><div class="line">    mode.<a class="code" href="classisce_1_1product_1_1ImageMode.html#ac8873bee9a7c1755db1b3704f32de956">numberAzimuthLooks</a>(10);</div><div class="line">    mode.<a class="code" href="classisce_1_1product_1_1ImageMode.html#aae662d41df064b5e8b2ca074e9957ec2">numberRangeLooks</a>(10);</div><div class="line">    <a class="code" href="structisce_1_1core_1_1DateTime.html">isce::core::DateTime</a> t0(<span class="stringliteral">&quot;2016-04-08T09:13:55.454821&quot;</span>);</div><div class="line">    mode.<a class="code" href="classisce_1_1product_1_1ImageMode.html#ac96ae93c5dc5f17c29a47cba5decd41e">startAzTime</a>(t0);</div><div class="line">    <a class="code" href="structisce_1_1core_1_1DateTime.html">isce::core::DateTime</a> t1(<span class="stringliteral">&quot;2016-04-08T09:14:10.454821&quot;</span>);</div><div class="line">    mode.<a class="code" href="classisce_1_1product_1_1ImageMode.html#aabc34685c8c7e52922d9d2499d1a3939">endAzTime</a>(t1);</div><div class="line"></div><div class="line">    <span class="comment">//Create Doppler polynomial - Zero Doppler for now</span></div><div class="line">    <a class="code" href="structisce_1_1core_1_1Poly2d.html">isce::core::Poly2d</a> dop(0,0,0.,0.,1.,1.);</div><div class="line">    dop.setCoeff(0,0,0.);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tt=0; tt&lt;targets.size(); tt++)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">double</span> rng;</div><div class="line">        <span class="keywordtype">double</span> aztime;</div><div class="line">       </div><div class="line">        <span class="comment">//Convert from degrees to radians</span></div><div class="line">        <a class="code" href="namespaceisce_1_1core.html#af1248fd6851624355b9af9c38decbad2">isce::core::cartesian_t</a> llh;</div><div class="line">        llh[0] = targets[tt][0] * M_PI / 180.0;</div><div class="line">        llh[1] = targets[tt][1] * M_PI / 180.0;</div><div class="line">        llh[2] = targets[tt][2];</div><div class="line"></div><div class="line">        <a class="code" href="geometry_8h.html#a16a51739a15e8aa39fd9525c293b2b95">isce::geometry::geo2rdr</a>( llh,       <span class="comment">//Target location</span></div><div class="line">                                 ellipse,   <span class="comment">//Ellipsoid</span></div><div class="line">                                 orbit,     <span class="comment">//Orbit</span></div><div class="line">                                 dop,       <span class="comment">//Doppler</span></div><div class="line">                                 mode,      <span class="comment">//Product metadata</span></div><div class="line">                                 aztime,    <span class="comment">//Estimated azimuth time</span></div><div class="line">                                 rng,       <span class="comment">//Estimated slant range</span></div><div class="line">                                 1.0e-8,    <span class="comment">//Convergence threshold</span></div><div class="line">                                 51,        <span class="comment">//Number of iterations</span></div><div class="line">                                 1.0e-8);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Target at: &quot;</span> &lt;&lt; targets[tt][0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; targets[tt][1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; targets[tt][2] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Estimated line number: &quot;</span> &lt;&lt; (aztime - mode.<a class="code" href="classisce_1_1product_1_1ImageMode.html#ac96ae93c5dc5f17c29a47cba5decd41e">startAzTime</a>().<a class="code" href="structisce_1_1core_1_1DateTime.html#aaec3f0ab4714653ab81e15b10e88f4b4">secondsSinceEpoch</a>(orbit.<a class="code" href="structisce_1_1core_1_1Orbit.html#a8332fb47800e74433493014f3c0e76b9">refEpoch</a>)) * mode.<a class="code" href="classisce_1_1product_1_1ImageMode.html#af99f799118ab544b0c7879697191c9ee">prf</a>() /   mode.<a class="code" href="classisce_1_1product_1_1ImageMode.html#ac8873bee9a7c1755db1b3704f32de956">numberAzimuthLooks</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Estimated pixel number: &quot;</span> &lt;&lt; (rng - mode.<a class="code" href="classisce_1_1product_1_1ImageMode.html#acd6e644e362aa3b9d9849bd2c7f1b61f">startingRange</a>())/mode.<a class="code" href="classisce_1_1product_1_1ImageMode.html#a84ce518a4dcca741568893388b9432c5">rangePixelSpacing</a>() / mode.<a class="code" href="classisce_1_1product_1_1ImageMode.html#aae662d41df064b5e8b2ca074e9957ec2">numberRangeLooks</a>() &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>; </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<hr>
Generated for ISCE3.0 by
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.8.14.
</body>
</html>
