//
// Author: Joshua Cohen
// Copyright 2017
//

#include <algorithm>
#include <cmath>
#include <iostream>
#include <vector>
#include "RasterBlockIter.h"
using std::cout;
using std::endl;
using std::max;
using std::min;
using std::vector;
using isce::dataio::RasterBlockIter;

template<typename T>
void RasterBlockIter::getNext(T *buffer, size_t width, size_t length, size_t band) {
    /*
     *  Gets the current block pointed to by _xidx/_yidx and increments the iterator. Since this
     *  uses an arbitrary memory buffer, we need to know the dimensions of the buffer being passed
     *  in (using length/width). Points to a specific band in the image.
     */
    // Check to see if we have the off-the-end iterator
    if (!atEOF()) {
        // Read block pointed to by the indices by using the _xidx/_yidx indices and the xskip/yskip
        // block offsets
      _raster.getBlock(buffer, _xidx*xskip(), _yidx*yskip(), width, length, band);
        operator++();
    } else {
        cout << "In RasterBlockIter::getNext() - Iterator has reached EOF." << endl;
    }
}

template<typename T>
void RasterBlockIter::getNext(T *buffer, size_t width, size_t length) {
    /*
     *  Gets the current block pointed to by the _xidx/_yidx indices and increments the iterator.
     *  Needs to know the size of the buffer since it's a raw pointer. Points to the default band.
     */
    getNext(buffer, width, length,  1);
}

template<typename T>
void RasterBlockIter::getNext(vector<T> &buffer, size_t width, size_t length, size_t band) {
    /*
     *  Gets the current block pointed to by the _xidx/_yidx indices and increments the iterator.
     *  Needs to know the size of the buffer because it's a linearly-contiguous 1D STL container, so
     *  we can't infer the data layout. Points to a specific image band.
     */
    getNext(buffer.data(), width, length, band);
}

template<typename T>
void RasterBlockIter::getNext(vector<T> &buffer, size_t width, size_t length) {
    /*
     *  Gets the current block pointed to by the _xidx/_yidx indices and increments the iterator. As
     *  above, needs to know the size of the buffer. Points to the default image band.
     */
  getNext(buffer.data(), width, length, 1);
}

template<typename T>
void RasterBlockIter::getNext(vector<vector<T>> &buffer, size_t band) {
    /*
     *  Gets the current block pointed to by the _xidx/_yidx indices and increments the iterator. In
     *  this case of using a 2D STL container buffer, we need to implement the matching getBlock()
     *  that really is a line reader. Points to a specific image band.
     *
     *  NOTE: AS WITH RASTER::GETBLOCK(CONTAINER<CONTAINER<T>>) THIS IMPLEMENTATION ACTUALLY CALLS
     *  ITERATIONS OF BLOCK READER AND MAY BE SIGNIFICANTLY SLOWER THAN THE OTHER BLOCK READERS.
     *  THIS METHOD IS ONLY IMPLEMENTED FOR CALLER CONVENIENCE AND IS NOT RECOMMENDED FOR FAST I/O
     *  NEEDS.
     */
    if (!atEOF()) {
      _raster.getBlock(buffer, _xidx*xskip(), _yidx*yskip(), band);
        operator++();
    } else {
        cout << "In RasterBlockIter::getNext() - Iterator has reached EOF." << endl;
    }
}

template<typename T>
void RasterBlockIter::getNext(vector<vector<T>> &buffer) {
    /*
     *  Gets the current block pointed to by the _xidx/_yidx indices and increments the iterator.
     *  Please refer to getNext(vector<vector<T>>&,size_t) above for implementation notes. Points to
     *  the default image band.
     */
    getNext(buffer, 1);
}

template<typename T>
void RasterBlockIter::setNext(T *buffer, size_t width, size_t length, size_t band) {
    /*
     *  Sets the current block pointed to by _xidx/_yidx and increments the iterator. Since this
     *  uses an arbitrary memory buffer, we need to know the dimensions of the buffer being passed
     *  in (using length/width). Points to a specific band in the image.
     */
    // Check to see if we have the off-the-end iterator
    if (!atEOF()) {
        // Read block pointed to by the indices by using the _xidx/_yidx indices and the xskip/yskip
        // block offsets
      _raster.setBlock(buffer, _xidx*xskip(), _yidx*yskip(), width, length, band);
        operator++();
    } else {
        cout << "In RasterBlockIter::setNext() - Iterator has reached EOF." << endl;
    }
}

template<typename T>
void RasterBlockIter::setNext(T *buffer, size_t width, size_t length) {
    /*
     *  Sets the current block pointed to by the _xidx/_yidx indices and increments the iterator.
     *  Needs to know the size of the buffer since it's a raw pointer. Points to the default band.
     */
    setNext(buffer, width, length, 1);
}

template<typename T>
void RasterBlockIter::setNext(vector<T> &buffer, size_t width, size_t length, size_t band) {
    /*
     *  Sets the current block pointed to by the _xidx/_yidx indices and increments the iterator.
     *  Needs to know the size of the buffer because it's a linearly-contiguous 1D STL container, so
     *  we can't infer the data layout. Points to a specific image band.
     */
    setNext(buffer.data(), width, length, band);
}

template<typename T>
void RasterBlockIter::setNext(vector<T> &buffer, size_t width, size_t length) {
    /*
     *  Sets the current block pointed to by the _xidx/_yidx indices and increments the iterator. As
     *  above, needs to know the size of the buffer. Points to the default image band.
     */
    setNext(buffer.data(), width, length, 1);
}

template<typename T>
void RasterBlockIter::setNext(vector<vector<T>> &buffer, size_t band) {
    /*
     *  Sets the current block pointed to by the _xidx/_yidx indices and increments the iterator. In
     *  this case of using a 2D STL container buffer, we need to implement the matching setBlock()
     *  that really is a line reader. Points to a specific image band.
     *
     *  NOTE: AS WITH RASTER::GETBLOCK(CONTAINER<CONTAINER<T>>) THIS IMPLEMENTATION ACTUALLY CALLS
     *  ITERATIONS OF BLOCK READER AND MAY BE SIGNIFICANTLY SLOWER THAN THE OTHER BLOCK READERS.
     *  THIS METHOD IS ONLY IMPLEMENTED FOR CALLER CONVENIENCE AND IS NOT RECOMMENDED FOR FAST I/O
     *  NEEDS.
     */
    if (!atEOF()) {
      _raster.setBlock(buffer, _xidx*xskip(), _yidx*yskip(), band);
        operator++();
    } else {
        cout << "In RasterBlockIter::setNext() - Iterator has reached EOF." << endl;
    }
}

template<typename T>
void RasterBlockIter::setNext(vector<vector<T>> &buffer) {
    /*
     *  Sets the current block pointed to by the _xidx/_yidx indices and increments the iterator.
     *  Please refer to setNext(vector<vector<T>>&,size_t) above for implementation notes. Points to
     *  the default image band.
     */
    setNext(buffer, 1);
}
